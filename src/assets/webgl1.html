<html>
  <head>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body></body>
  <script>
    // 初始化 webgl 配置
    function initWebGL() {
      // 创建 canvas 元素 设置宽高 添加到 body 下
      const canvas = document.createElement("canvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      document.body.appendChild(canvas);

      // 判断浏览器对 webgl 的兼容性
      if (
        !canvas.getContext("webgl") &&
        !canvas.getContext("experimental-webgl")
      ) {
        alert("你的浏览器不支持 webgl");
        return;
      }

      // 若支持 获取 webgl 上下文
      const gl =
        canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

      // 设置视口  context.viewport(x, y, width, height);
      gl.viewport(0, 0, canvas.width, canvas.height);

      return gl;
    }

    // 语法 gl.createShader(type) 此处 type 为枚举型值为 gl.VERTEX_SHADER 或 gl.FRAGMENT_SHADER 两者中的一个
    // gl.shaderSource(shader, source); shader - 用于设置程序代码的 webglShader（着色器对象) source - 包含 GLSL 程序代码的字符串
    // 配置顶点多色契合片元着色器
    const gl = initWebGL();
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

    // 语法 gl.shaderSource(shader, source) 此处 shader 为 shader 对象 source 为 shader 源码
    gl.shaderSource(
      vertexShader, // 顶点着色器对象
      // attribute vec4 v_position; 传入一个四位变量 v_position，并将变量通过主函数 main 传递给内置变量 gl_Position
      `
      attribute vec4 v_position;

      void main() {
        gl_Position = v_position;
      }
    `
    );
    gl.compileShader(vertexShader);

    gl.shaderSource(
      fragmentShader, // 片元着色器对象
      `
      precision mediump float; // 设置浮点数精度为中等

      uniform vec4 f_color; // 传入一个四位变量 u_color，并将变量通过主函数 main 传递给内置变量 gl_FragColor

      void main() {
        gl_FragColor = f_color;
      }
    `
    );
    gl.compileShader(fragmentShader);

    // 创建程序连接顶点着色器和片元着色器
    const program = gl.createProgram(); // 创建一个空的 WebGL 程序对象
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    // 获取 uniform 内 f_color 变量的位置
    const color = gl.getUniformLocation(program, "f_color");
    // 根据位置修改值
    gl.uniform4f(color, 1.0, 0.0, 0.0, 1.0);

    const position = gl.getAttribLocation(program, "v_position");
    // 因为可能存在多个节点，所以需要开启顶点缓冲区
    const pBuffer = gl.createBuffer();
    // 将 pbuffer 绑定到目标 gl.ARRAY_BUFFER
    gl.bindBuffer(gl.ARRAY_BUFFER, pBuffer);
    // 将数据写入缓冲区，通过 Float32Array 将数据转换为浮点数数组，并传入到缓冲区中
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([0.0, 0.5, 0.5, 0, -0.5, -0.5]),
      gl.STATIC_DRAW // 静态绘制，数据不会被修改
    );

    // 告诉 webgl 如何解析缓冲区中的数据
    gl.vertexAttribPointer(
      position, // 指定要修改的顶点属性索引
      2, // 每个顶点属性的组成数量，必须是 1，2，3 或 4。
      gl.FLOAT, // 数组中每个元素的类型
      false, // 是否归一化到特定的范围，对 FLOAT 类型数据设置无效
      0, // stride 步长 数组中一行长度，0 表示数据是紧密的没有空隙，让 OpenGL 决定具体步长
      0 // offset 字节偏移量，必须是类型的字节长度的倍数。
    );
    // 开启 attribute 变量，是顶点着色器能访问缓冲区数据
    gl.enableVertexAttribArray(position);

    gl.clearColor(0, 1, 1, 1); // 设置清空颜色为蓝色
    gl.clear(gl.COLOR_BUFFER_BIT); // 清空颜色缓冲区

    // 语法 gl.drawArrays(mode, first, count); mode - 指定绘制图元的方式 first - 指定从哪个点开始绘制 count - 指定绘制需要使用到多少个点
    gl.drawArrays(gl.TRIANGLES, 0, 3); // 绘制三角形，0 表示从缓冲区中的第一个顶点开始，3 表示绘制 3 个顶点
  </script>
</html>
